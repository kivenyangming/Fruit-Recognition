# 水果识别

## 摘要：

本项目针对多种常见水果混合的图像，利用 Matlab 软件，对水果的识别进行研究。根据水果和背景的差别选取阈值，对去噪增强对比度后的图像进行二值化处理。再对图像进行边缘检测，选定连通区域，标记后再对不同种水果的颜色，形状，大小等特征进行快速识别水果，从而实现对水果的正确分拣。

__关键字__：水果识别、MATLAB、数字图像处理


## 一、设计方案

在计算机中，图像由像素逐点描述，每个像素点都有一个明确的位置和色彩数值。使用 Matlab 软件读取图像，以矩阵形式存放图像数据，其扫描规则是从左向右，从上到下。

对于一副水果图像为了处理方便，我们首先要把彩色图像转化为灰度图像。然后对图像进行二值化处理来获得每个水果的区域特征。

在水果与背景接触处二值化会导致图像边缘部分有断裂，毛躁的部分。所以采用边缘提取以弥补断裂的边缘部分，然后基于数学形态算子对图像进行去除断边，图像填充等必要的后续处理。经过图像分割后，水果和背景很明显地被区分开来，然后需要对每种水果的特征进行提取。

先对图像进行标签化，所谓图像的标签化是指对图像中互相连通的所有像素赋予同样的标号。经过标签化处理就能把各个连通区域进行分离，从而可以研究它们的特征。


## 二、关键技术

### （一）图像二值化

#### 1、灰度化

    % 将真彩色图像 i 转化为灰度图像 I
    I=rgb2gray(i); 

在 RGB 模型中，如果 R=G=B 时，则彩色表示一种灰度颜色，其中 R=G=B 的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。

#### 2、二值化

    % level 为阈（yu) 值，取值从0到1.
    % 本项目考虑到图片背景颜色为白色，亮度较大，因此选取 `level=0.9` 来实现二值化。
    I=im2bw（i，level）

一幅图像包含目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，最经常使用的方法就是设定一个全局的阈值 T，用 T 将图像的数据分成两部分：大于 T 的像素群和小于 T 的像素群。将大于 T 的像素群的像素值设定为白色（或者黑色），小于 T 的像素群的像素值设定为黑色（或者白色）。

比方：计算每个像素的（R+G+B）/3，假设>127，则设置该像素为白色，即R=G=B=255；否则设置为黑色，即R=G=B=0。

### （二）边缘提取

#### 1、开运算

    I=imopen(i,SE);

先腐蚀后膨胀的过程称为开运算。（看上去把细微连在一起的两块目标分开了）

开运算作用：可以使边界平滑，消除细小的尖刺，断开窄小的连接,保持面积大小不变等。

    I=imerode（i，SE）;

腐蚀运算作用：消除物体边界点，使边界点向内部收缩，可以把小于结构元素的物体去除。

膨胀的作用：将与物体接触的所有背景点合并到物体中，是目标增大，可填补目标中的空洞。

#### 2、数学形态学运算

    % bwmorph 函数是对图像进行指定的形态学操作。
    % ‘remove’即代表如果一个像素点的4邻域都为1， 则该像素点将被置0；该选项将导致边界像素上的1被保留下来。
    I=bwmorph（i，'remove'）;

提取图像种水果的边界用于标记各个区域

### （三）水果分类

#### 1、获得连通区域的属性

这里要用到了在 Matlab 图像处理工具箱中非常重要的一个图像分析函数：regionprops．

顾名思义：它的用途是 get the properties of region ，即用来度量图像区域属性的函数．

    STATS =regionprops(L,properties)

描述测量标注矩阵L中每一个标注区域的一系列属性．L中不同的正整数元素对应不同的区域，例如：L中等于整数1的元素对应区域1；L中等于整数2的元素对应区域2；以此类推．

此函数用来获取每个水果的中心位置，及其外接椭圆的长，短轴长度。中心位置用来计算水果的颜色特征值及最终显示水果名称。外接椭圆的长，短轴长度用来计算水果的似圆性特征，以判断其大致形状。

#### 2、获取特征并判别函数

本项目根据水果在图像中表现出来的特点，从面积特征，似圆性特征，颜色（rgb值和hsv值）特征对图像中的桃子、苹果、香蕉 、西瓜、菠萝、梨子等进行特征提取。最后按照筛选出来的特征对水果进行分类识别。

##### （1）颜色特征
本项目使用两种计量方式来测得水果的颜色值。

###### RGB颜色模式

对于彩色图像，可分解为 RGB 三幅单色图像。每一副图像中的像素分布情况都代表了改颜色的程度信息。根据常识可知上述6种水果中苹果和桃子的红色含量要比其他水果丰富的多，西瓜的红色含量最小。

###### Hsv颜色模式

这个模型中颜色的参数分别是：色彩（H），纯度（S），明度（V）。 HSV模型的三维表示从RGB立方体演化而来。设想从RGB沿立方体对角线的白色顶点向黑色顶点观察，就可以看到立方体的六边形外形。六边形边界表示色彩，水平轴表示纯度，明度沿垂直轴测量。

- H参数表示色彩信息，即所处的光谱颜色的位置。该参数用一角度量来表示，红、绿、蓝分别相隔120度。互补色分别相差180度。

- 纯度S为一比例值，范围从0到1，它表示成所选颜色的纯度和该颜色最大的纯度之间的比率。S=0时，只有灰度。

- V表示色彩的明亮程度，范围从0到1。有一点要注意：它和光强度之间并没有直接的联系。

##### （2）似圆性特征

似圆性是在计算出每块连通区域的外接椭圆的短轴长度和长轴长度，来测量水果形状的似圆性。我们用长轴长度除以短轴长度得到一个比例。这个值与1越接近，说明水果与圆越相似。同理，该值越比1大，说明水果越不像圆。根据常识可知，上述6个水果中西瓜，苹果，桃子似圆性很高，而香蕉，菠萝似圆性最低。

##### （3）面积特征
经过标签化的不同区域的面积，可以用该区域像素数量来计算。对整幅图像进行扫描，计算所有连通区域的面积。根据常识可知：西瓜在上述6个水果中面积是最大的一个，菠萝其次。

#### 3、特征统计表格

![原始图像1](https://pic.downk.cc/item/5e059e8476085c3289ac5b0b.jpg)

|原始图像1|梨子|苹果|桃子|香蕉|菠萝
|-|-|-|-|-|-|-
|r|0.94|0.80|0.72|1.04|0.55
|g|0.81|0.17|0.19|0.85|0.56
|b|0.28	|0.06|0.13|0.53	|0.47
|Hsv均值|0.11|0.2|0.5|0.16|0.26
|面积|2671|2224|1936|3604|3361
|似圆性|1.6|1.1|1.07|1.78|1.55

![原始图像2](https://pic.downk.cc/item/5e059f0776085c3289ac7418.jpg)

|原始图像2|香蕉|桃子	|梨子	|西瓜	|苹果
|-|-|-|-|-|-|-
|r|1.03	|1.01	|0.9	|0.29	|1.01
|g	|0.95	|0.99	|0.73	|0.38	|0.99
|b	|0.20	|1.0	|0.35	|0.22	|1.00
|Hsv值	|0.14	|0.25	|0.11	|0.29	|0.89
|面积	|2191	|1572	|1387	|2914	|1443
|似圆性	|2.2	|1.0	|1.6	|1.0	|1.03

![原始图像3](https://pic.downk.cc/item/5e059f2576085c3289ac792c.jpg)

|原始图像3	|苹果	|桃子	|西瓜	|香蕉	|梨子
|-|-|-|-|-|-|-
|r	|0.86	|1.07	|0.20	|0.92	|1.02
|g	|0.19	|1.06	|0.53	|0.31	|1.00
|b	|0.22	|1.06	|0.30	|0.26	|0.95
|Hsv值	|0.63	|0.26	|0.39	|0.12	|0.108
|面积	|1190	|1660	|2328	|1894	|1082
|似圆性	|1.12	|1.06	|1.13	|2.16	|1.6921



#### 4、特征选择及最终结果图

__梨子__

梨子的hsv值是最小的，且因为梨子有柄的关系，梨子的似圆性在1.4至1.6之间，梨子的r值和g值都普遍大于0.6；

__苹果__

苹果的似圆性在1至1.1之间，苹果红的色素较多，蓝色和绿色色素较少使得其g值和b值都普遍小于0.4；

__桃子__

似圆性在1至1.2之间，hsv的值小于0.6，红色色素较多使得其r值至少为0.7；

__香蕉__

香蕉的似圆性数值是最大的至少为1.8，且其成黄色，其hsv的值都小于0.2；

__菠萝__

菠萝的似圆性数值仅次于香蕉为第二大，其hsv值都小于0.3，且其红色色素少r值都小于0.7；

__西瓜__

西瓜的面积是所有水果中最大的，且其红色色素较少r值都小于0.4，，似圆性在1至1.2之间；


根据水果在图像中表现出来的特点，从面积特征，似圆性特征，颜色（rgb值和hsv值）特征对图像中的桃子、苹果、香蕉、西瓜、菠萝、梨子等进行特征提取。最后按照筛选出来的特征对水果进行分类识别。

识别结果图如下所示：

![图1的识别结果图 ](https://pic.downk.cc/item/5e059f9976085c3289ac9197.jpg)

![图2的识别结果图 ](https://pic.downk.cc/item/5e059fb076085c3289ac95e2.jpg)

![图3的识别结果图 ](https://pic.downk.cc/item/5e059fe676085c3289aca566.jpg)



## 三、程序代码

```matlab
clc;
clear all;
img=imread('2hei.bmp');  
R=img(:,:,1);           %获取彩色图像的r值。
G=img(:,:,2);           %获取彩色图像的g值。
B=img(:,:,3);           %获取彩色图像的b值。
I2=rgb2gray(img);       %将图像灰度化。
figure,imshow(I2),title('灰度图像');
BW=im2bw(I2,0.9);       %将图像二值化。

SE=strel('rectangle',[40 30]);      % 结构定义
J2=imopen(BW,SE);                   % 进行开运算去除噪声和平滑边界
figure,imshow(J2),title('对二值图像进行开运算后的结果图像');
SE=strel('square',3);                % 定义3×3腐蚀结构元素
J=imerode(~J2,SE);                   %对图像进行腐蚀操作。
BW2=(~J2)-J;                         % 检测边缘


%填充了已有的检测的连续形状边界
B = imfill(BW2,'holes');            %对图像填充孔洞。
B = bwmorph(B,'remove');            %获得图像中区域边界。


%将不同的图形进行分别标记，num表示连接的图形对象的个数
[Label,num] = bwlabel(B);           %进行标记。
for i = 1 : num
    Area(i) = 0;
end
Label = imfill(Label,'holes');       %填充打过标记的边界线中间围成的图形区域


%计算各个图像的hsv颜色（色度）

HSV = rgb2hsv(img);                  %转换为HSV颜色模型。

[row,col] = size(Label);             %统计填充后的图形中各块图形所含像素的个数的多少
MeanHue = zeros(1,num);             %初始化
    for i = 1 : num
        Hue = zeros(Area(i),1);     %初始化
        nPoint = 0;                 %初始化
        for j = 1 : row
            for k = 1 : col
                if(Label(j,k) == i)
                    nPoint = nPoint + 1;            %对于是连通区域中的点npoint+1.
                    Hue(nPoint,1) = HSV(j,k,1);     %把hsv的值赋给Hue数组。
                end
            end
        end
        
        Hue(:,i) = sort(Hue(:,1));
        for j = floor(nPoint*0.1) : floor(nPoint*0.9)
            MeanHue(i) = MeanHue(i) + Hue(j,1);     %将hsv(i)的值赋给MeanHue(i)
        end
        MeanHue(i) = MeanHue(i) / (0.8*nPoint);     %计算出平均的色度值
    end

%调用regionprops函数获得各个联通区域的属性值(中心点坐标，外接椭圆的长短轴长度，面积)。
[L,num]=bwlabel(BW2);                               %重新进行区域标记。
stats= regionprops(L, 'ALL');                       %调用regionprops函数。
for i= 1:num
longth(i)=stats(i).MajorAxisLength;                 %获得外接椭圆的长轴长度
width(i)=stats(i).MinorAxisLength;                  %获得外接椭圆的短轴长度
end
%初始化。
R2=0;
G2=0;
B2=0;
x=0;
y=0;
%求出似圆性。
for i=1:num
    r(i)=0;
    g(i)=0;
    b(i)=0;
    yuan(i)=longth(i)/width(i);%长轴长度/短轴长度为似圆性特征。
end

%获得以每个水果重心为中心点的边长为30的正方形内的像素的rgb值
for i=1:num
    for j=(round(stats(i).Centroid(1))-15):(round(stats(i).Centroid(1))+15)
        for k=(round(stats(i).Centroid(2))-15):(round(stats(i).Centroid(2))+15)
            R2=im2double(img(j,k,1));
            G2=im2double(img(j,k,2));
            B2=im2double(img(j,k,3));
            r(i)=r(i)+R2;
            g(i)=g(i)+G2;
            b(i)=b(i)+B2;
        end
    end
    r(i)=r(i)/900;
    g(i)=g(i)/900;
    b(i)=b(i)/900;
end

%求出水果中面积最大值用于判定
for i=1:num
    if(stats(i,1).Area>x)
        x=stats(i,1).Area;
    end
end

%求出水果中hsv的最小值用于判定
y=MeanHue(1);
for i=1:num
    if(y>MeanHue(i))
        y=MeanHue(i);
    end
end



%显示最终分类结果图。
figure,imshow(img);
hold on
%梨子分类算法
for i=1:num
    if(MeanHue(i)==y && yuan(i)>1.3 && r(i)>0.7 && g(i)>0.7)
        text(stats(i).Centroid(1),stats(i).Centroid(2),'类别:梨子');
    end
end

%苹果分类算法
for i=1:num
    if(r(i)>0.75 && yuan(i)<1.15  && g(i)<0.4 && b(i)<0.3)
         text(stats(i).Centroid(1),stats(i).Centroid(2),'类别:苹果');
    end
end

%桃子分类算法
for i=1:num
    if(MeanHue(i)<0.6 && yuan(i)<1.25 && r(i)>0.7 &&b(i)>0.1)
        text(stats(i).Centroid(1),stats(i).Centroid(2),'类别:桃子');
    end
end

%香蕉分类算法
for i=1:num
    if(MeanHue(i)<0.2 && yuan(i)>1.7)
         text(stats(i).Centroid(1),stats(i).Centroid(2),'类别:香蕉');
    end
end

%菠萝分类算法
for i=1:num
    if(MeanHue(i)<0.3 && yuan(i)>1.4&& r(i)<0.8 )
        text(stats(i).Centroid(1)+30,stats(i).Centroid(2)+30,'类别:菠萝');
    end
end

%西瓜分类算法
for i=1:num
    if( stats(i,1).Area==x && yuan(i)<1.25&& r(i)<0.4)
        text(stats(i).Centroid(1),stats(i).Centroid(2),'类别:西瓜');
    end
end
```

## 四、结论

总的来说水果识别良好，识别较为准确。

对于偏亮和偏暗的图像，由于项目同时采用了hsv模型和rgb模型判断，因此图片的亮度对识别没有太大影响，识别率还算理想。但是正是由于获取颜色特征时同时采用hsv模型和rgb模型的值判断，导致去噪参数不能太大，待识别图片出现较多噪声的情况下识别不是太理想，因此有些识别存在误差。

而如果放弃使用hsv模型或者rgb模型中的一个，则能较好进行去除噪声，但是这样颜色特征有少了一样，对于偏亮和偏暗的图像，颜色判定时会有误差，这是没有解决好的一个主要问题。











